// Copyright (c) 2021 The powermirror developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package lightmirror

import (
	"bytes"
	"reflect"
	"testing"
	"time"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/wire"
	"github.com/davecgh/go-spew/spew"
)

// mainNetGenesisHash is the hash of the first block in the block chain for the
// main network (genesis block).
var mainNetGenesisHash = chainhash.Hash([chainhash.HashSize]byte{ // Make go vet happy.
	0x6f, 0xe2, 0x8c, 0x0a, 0xb6, 0xf1, 0xb3, 0x72,
	0xc1, 0xa6, 0xa2, 0x46, 0xae, 0x63, 0xf7, 0x4f,
	0x93, 0x1e, 0x83, 0x65, 0xe1, 0x5a, 0x08, 0x9c,
	0x68, 0xd6, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
})

// mainNetGenesisMerkleRoot is the hash of the first transaction in the genesis
// block for the main network.
var mainNetGenesisMerkleRoot = chainhash.Hash([chainhash.HashSize]byte{ // Make go vet happy.
	0x3b, 0xa3, 0xed, 0xfd, 0x7a, 0x7b, 0x12, 0xb2,
	0x7a, 0xc7, 0x2c, 0x3e, 0x67, 0x76, 0x8f, 0x61,
	0x7f, 0xc8, 0x1b, 0xc3, 0x88, 0x8a, 0x51, 0x32,
	0x3a, 0x9f, 0xb8, 0xaa, 0x4b, 0x1e, 0x5e, 0x4a,
})

func TestBtcLightMirrorSerialize(t *testing.T) {
	nonce := uint32(123123) // 0x1e0f3
	
	bits := uint32(0x1d00ffff)
	btcLightMirror := &BtcLightMirror{
		BtcHeader : wire.BlockHeader{
			Version:    1,
			PrevBlock:  mainNetGenesisHash,
			MerkleRoot: mainNetGenesisMerkleRoot,
			Timestamp:  time.Unix(0x495fab29, 0), // 2009-01-03 12:15:05 -0600 CST
			Bits:       bits,
			Nonce:      nonce,
		},
		CoinBaseTx : wire.MsgTx{
			Version: 1,
			TxIn: []*wire.TxIn{
				{
					PreviousOutPoint: wire.OutPoint{
						Hash:  chainhash.Hash{},
						Index: 0xffffffff,
					},
					SignatureScript: []byte{
						0x04, 0x31, 0xdc, 0x00, 0x1b, 0x01, 0x62,
					},
					Sequence: 0xffffffff,
				},
			},
			TxOut: []*wire.TxOut{
				{
					Value: 0x12a05f200,
					PkScript: []byte{
						0x41, // OP_DATA_65
						0x04, 0xd6, 0x4b, 0xdf, 0xd0, 0x9e, 0xb1, 0xc5,
						0xfe, 0x29, 0x5a, 0xbd, 0xeb, 0x1d, 0xca, 0x42,
						0x81, 0xbe, 0x98, 0x8e, 0x2d, 0xa0, 0xb6, 0xc1,
						0xc6, 0xa5, 0x9d, 0xc2, 0x26, 0xc2, 0x86, 0x24,
						0xe1, 0x81, 0x75, 0xe8, 0x51, 0xc9, 0x6b, 0x97,
						0x3d, 0x81, 0xb0, 0x1c, 0xc3, 0x1f, 0x04, 0x78,
						0x34, 0xbc, 0x06, 0xd6, 0xd6, 0xed, 0xf6, 0x20,
						0xd1, 0x84, 0x24, 0x1a, 0x6a, 0xed, 0x8b, 0x63,
						0xa6, // 65-byte signature
						0xac, // OP_CHECKSIG
					},
				},
				{
					Value: 0x5f5e100,
					PkScript: []byte{
						0x41, // OP_DATA_65
						0x04, 0xd6, 0x4b, 0xdf, 0xd0, 0x9e, 0xb1, 0xc5,
						0xfe, 0x29, 0x5a, 0xbd, 0xeb, 0x1d, 0xca, 0x42,
						0x81, 0xbe, 0x98, 0x8e, 0x2d, 0xa0, 0xb6, 0xc1,
						0xc6, 0xa5, 0x9d, 0xc2, 0x26, 0xc2, 0x86, 0x24,
						0xe1, 0x81, 0x75, 0xe8, 0x51, 0xc9, 0x6b, 0x97,
						0x3d, 0x81, 0xb0, 0x1c, 0xc3, 0x1f, 0x04, 0x78,
						0x34, 0xbc, 0x06, 0xd6, 0xd6, 0xed, 0xf6, 0x20,
						0xd1, 0x84, 0x24, 0x1a, 0x6a, 0xed, 0x8b, 0x63,
						0xa6, // 65-byte signature
						0xac, // OP_CHECKSIG
					},
				},
			},
			LockTime: 0,
		},
	}

	btcLightMirror.TxHashes = append(btcLightMirror.TxHashes, btcLightMirror.CoinBaseTx.TxHash())


	blmEncoded := []byte{
		0x01,0x00,0x00,0x00,0x6f,0xe2,0x8c,0x0a,0xb6,0xf1,0xb3,0x72,0xc1,0xa6,0xa2,0x46,
		0xae,0x63,0xf7,0x4f,0x93,0x1e,0x83,0x65,0xe1,0x5a,0x08,0x9c,0x68,0xd6,0x19,0x00,
		0x00,0x00,0x00,0x00,0x3b,0xa3,0xed,0xfd,0x7a,0x7b,0x12,0xb2,0x7a,0xc7,0x2c,0x3e,
		0x67,0x76,0x8f,0x61,0x7f,0xc8,0x1b,0xc3,0x88,0x8a,0x51,0x32,0x3a,0x9f,0xb8,0xaa,
		0x4b,0x1e,0x5e,0x4a,0x29,0xab,0x5f,0x49,0xff,0xff,0x00,0x1d,0xf3,0xe0,0x01,0x00,
		0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x07,0x04,0x31,0xdc,0x00,0x1b,0x01,
		0x62,0xff,0xff,0xff,0xff,0x02,0x00,0xf2,0x05,0x2a,0x01,0x00,0x00,0x00,0x43,0x41,
		0x04,0xd6,0x4b,0xdf,0xd0,0x9e,0xb1,0xc5,0xfe,0x29,0x5a,0xbd,0xeb,0x1d,0xca,0x42,
		0x81,0xbe,0x98,0x8e,0x2d,0xa0,0xb6,0xc1,0xc6,0xa5,0x9d,0xc2,0x26,0xc2,0x86,0x24,
		0xe1,0x81,0x75,0xe8,0x51,0xc9,0x6b,0x97,0x3d,0x81,0xb0,0x1c,0xc3,0x1f,0x04,0x78,
		0x34,0xbc,0x06,0xd6,0xd6,0xed,0xf6,0x20,0xd1,0x84,0x24,0x1a,0x6a,0xed,0x8b,0x63,
		0xa6,0xac,0x00,0xe1,0xf5,0x05,0x00,0x00,0x00,0x00,0x43,0x41,0x04,0xd6,0x4b,0xdf,
		0xd0,0x9e,0xb1,0xc5,0xfe,0x29,0x5a,0xbd,0xeb,0x1d,0xca,0x42,0x81,0xbe,0x98,0x8e,
		0x2d,0xa0,0xb6,0xc1,0xc6,0xa5,0x9d,0xc2,0x26,0xc2,0x86,0x24,0xe1,0x81,0x75,0xe8,
		0x51,0xc9,0x6b,0x97,0x3d,0x81,0xb0,0x1c,0xc3,0x1f,0x04,0x78,0x34,0xbc,0x06,0xd6,
		0xd6,0xed,0xf6,0x20,0xd1,0x84,0x24,0x1a,0x6a,0xed,0x8b,0x63,0xa6,0xac,0x00,0x00,
		0x00,0x00,0x01,0x9d,0x0e,0x29,0x88,0x3d,0x9b,0xdc,0x34,0x65,0x5a,0x80,0xe4,0xd1,
		0x7d,0xb7,0xa1,0x79,0x63,0xa5,0xa0,0x4c,0x16,0x5c,0xe0,0x8d,0xf3,0x2f,0x52,0x5a,
		0xd1,0x00,0x01,
	}

	tests := []struct {
		in  *BtcLightMirror // Data to encode
		out *BtcLightMirror // Expected decoded data
		buf []byte       // Serialized data
	}{
		{
			btcLightMirror,
			btcLightMirror,
			blmEncoded,
		},
	}

	t.Logf("Running %d tests", len(tests))
	for i, test := range tests {
		// Serialize the block header.
		var buf bytes.Buffer
		err := test.in.Serialize(&buf)

		t.Log(buf)
		if err != nil {
			t.Errorf("Serialize #%d error %v", i, err)
			continue
		}
		if !bytes.Equal(buf.Bytes(), test.buf) {
			t.Errorf("Serialize #%d\n got: %s want: %s", i,
				spew.Sdump(buf.Bytes()), spew.Sdump(test.buf))
			continue
		}

		// Deserialize the block header.
		var bh BtcLightMirror
		rbuf := bytes.NewReader(test.buf)
		err = bh.Deserialize(rbuf)
		if err != nil {
			t.Errorf("Deserialize #%d error %v", i, err)
			continue
		}
		if !reflect.DeepEqual(&bh, test.out) {
			t.Errorf("Deserialize #%d\n got: %s want: %s", i,
				spew.Sdump(&bh), spew.Sdump(test.out))
			continue
		}
	}
}
